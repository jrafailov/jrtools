alias sqwatch='watch "squeue -u $USER -o \"%.18i %.10P %.100j %.8u %.2t %.10M %.6D %R\""'
alias sqrun='watch "squeue -t running -u $USER -o '\''%.10i %.100j %.8u %.4t %.12M %.8C %.10m %.25N %r'\''"'
alias sqrunmem='watch "squeue -t running -u $USER -o '\''%.10i %.100j %.8u %.4t %.12M %.8C %.10m %.25N %r'\'' | sort -k7 -r"'
alias sqpend='watch "squeue --sort=i -t pending -u $USER -o '\''%.10i %.100j %.8u %.4t %.12M %.8C %.10m %.25N %r'\''"'
alias squeue_pend_mem='watch "squeue --sort=i -t pending -u $USER -o '\''%.10i %.100j %.8u %.4t %.12M %.8C %.10m %.25N %r'\'' | sort -k7 -nr"'
alias sqr="watch squeue -u $USER -t running"
alias sqp="watch squeue -u $USER -t pending"
alias sq="watch squeue -u $USER"
alias sqrunn="watch 'squeue -u $USER -t running | wc -l'"
alias sqpendn="watch 'squeue -u $USER -t pending | wc -l'"
alias job-info='scontrol show job'

hunt() {
 case "$1" in
  --mem)
   ps -eo user:32,rss --no-headers \
   | awk '{mem[$1]+=$2} END {for (u in mem) printf "%-32s %9.2f GiB\n", u, mem[u]/1024/1024}' \
   | sort -k2,2nr
   ;;

  --cpu)
   # Sum %CPU per user; convert to "core-equivalents" = sum(%CPU)/100
   total_cores=$(nproc 2>/dev/null || getconf _NPROCESSORS_ONLN)
   ps -eo user:32,pcpu --no-headers \
   | awk -v ncores="${total_cores:-0}" '
     {cpu[$1]+=$2}
     END {
      for (u in cpu) {
       ce = cpu[u]/100.0
       util = (ncores>0) ? (100.0*ce/ncores) : 0
       printf "%-32s %9.2f cores (%6.2f%% of node)\n", u, ce, util
      }
     }' \
   | sort -k2,2nr
   ;;

  *)
   echo "usage: hunt_local --mem | --cpu" >&2
   return 2
   ;;
 esac
}

# ---------------------------------------------------------------------------
# Function: squeuelab
# Description:
#   Displays the SLURM queue for all users found in the ~/lab/home directory.
# Parameters:
#   None
# Returns:
#   Exits with status 1 if ~/lab/home directory doesn't exist or is empty.
# Usage:
#   squeuelab
# ---------------------------------------------------------------------------
function squeuelab {
	if [ ! -d ~/lab/home ]; then
		echo "Error: ~/lab/home directory not found"
		return 1
	fi
	
	users=$(ls ~/lab/home 2>/dev/null)
	if [ -z "$users" ]; then
		echo "Error: No users found in ~/lab/home"
		return 1
	fi
	
	user_list=$(echo $users | tr ' ' ',')
	squeue -u "$user_list" -o "%.18i %.10P %.100j %.8u %.2t %.10M %.6D %R"
}

# ---------------------------------------------------------------------------
# Function: jobstderr
# Description:
#   Retrieves the path to the standard error file associated with a SLURM job 
#   and displays its contents continuously in real-time.
# Parameters:
#   job_id - The unique identifier for the SLURM job.
# Returns:
#   Exits with status 1 if:
#     - No job_id is provided.
#     - The standard error file path cannot be determined.
# Usage:
#   jobstderr <job_id>
# ---------------------------------------------------------------------------
function job_stderr {
 if [ -z "$1" ]; then
 echo "Usage: jobstderr <job_id>"
 return 1
 fi
 stderr_file=$(scontrol show job "$1" | grep -oP 'StdErr=\K\S+')
 if [ -z "$stderr_file" ]; then
 echo "StdErr file not found for job $1"
 return 1
 fi
 tail -f "$stderr_file"
}

# ---------------------------------------------------------------------------
# Function: jobcwd
# Description:
#   Changes the current working directory of the shell to the working directory
#   associated with a specified SLURM job.
# Parameters:
#   job_id - The unique identifier for the SLURM job.
# Returns:
#   Exits with status 1 if:
#     - No job_id is provided.
#     - The working directory information cannot be retrieved.
# Usage:
#   jobcwd <job_id>
# ---------------------------------------------------------------------------
function job_cwd {
 if [ -z "$1" ]; then
 echo "Usage: jobcwd <job_id>"
 return 1
 fi
 cwd=$(scontrol show job "$1" | grep -oP 'WorkDir=\K\S+')
 if [ -z "$cwd" ]; then
 echo "Working directory not found for job $1"
 return 1
 fi
 cd "$cwd" && echo "Switched to $cwd"
}

# ---------------------------------------------------------------------------
# Function: scancelgrep
# Description:
#   Cancels all SLURM jobs for the current user that match a given pattern
#   in their job names using grep. Optionally filter by job state.
# Parameters:
#   pattern - The pattern to search for in job names (required)
#   -t state - Optional job state filter (all, running, pending). Default: all
# Returns:
#   Exits with status 1 if no pattern is provided or no matching jobs found.
# Usage:
#   scancelgrep <pattern> [-t state]
#   scancelgrep [-t state] <pattern>
# ---------------------------------------------------------------------------
function scancelgrep {
	local pattern=""
	local state="all"
	
	# Parse arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
			-t)
				if [[ -n "$2" && "$2" =~ ^(all|running|pending)$ ]]; then
					state="$2"
					shift 2
				else
					echo "Error: -t requires one of: all, running, pending"
					return 1
				fi
				;;
			*)
				if [ -z "$pattern" ]; then
					pattern="$1"
					shift
				else
					echo "Error: Multiple patterns not supported"
					return 1
				fi
				;;
		esac
	done
	
	if [ -z "$pattern" ]; then
		echo "Usage: scancelgrep <pattern> [-t state]"
		echo "       scancelgrep [-t state] <pattern>"
		echo "States: all, running, pending (default: all)"
		return 1
	fi
	
	# Build squeue command based on state
	local squeue_cmd="squeue -u $USER -h -o \"%.18i %.100j\""
	if [ "$state" != "all" ]; then
		squeue_cmd="squeue -u $USER -t $state -h -o \"%.18i %.100j\""
	fi
	
	local job_ids=$(eval $squeue_cmd | grep "$pattern" | awk '{print $1}')
	
	if [ -z "$job_ids" ]; then
		echo "No jobs found matching pattern: $pattern (state: $state)"
		return 1
	fi
	
	echo "Found jobs matching pattern '$pattern' (state: $state):"
	eval $squeue_cmd | grep "$pattern"
	echo
	read -p "Cancel these jobs? (y/N): " confirm
	
	if [[ $confirm == [yY] || $confirm == [yY][eE][sS] ]]; then
		echo "$job_ids" | xargs scancel
		echo "Jobs cancelled."
	else
		echo "Cancelled operation."
	fi
}
# ---------------------------------------------------------------------------
# Function: reassign_jobs
# Description:
#   Reassigns SLURM jobs matching a pattern to specified partitions.
#   By default, looks for pending jobs with 'nf-' in the job name.
# Parameters:
#   pattern - Pattern to search for in job names (default: 'nf-')
#   -p|--partition - Comma-separated list of partitions (default: all available)
#   -t|--state - Job state to filter (default: 'pending')
#   -u|--user - Username to filter jobs (default: current user)
#   --dry-run - Show what would be done without executing
# Returns:
#   Exits with status 0 on success, 1 on error.
# Usage:
#   reassign_jobs [pattern] [-p partitions] [-t state] [-u user] [--dry-run]
# ---------------------------------------------------------------------------
function reassign_jobs() {
	local PARTS="cpu_short,cpu_medium,cpu_long,fn_short,fn_medium,fn_long,gpu4_dev,gpu4_short,gpu4_medium,gpu4_long,gpu8_short,gpu8_medium,gpu8_long,a100_short,a100_long"
	local DRYRUN=0
	local STATE="pending"
	local USERNAME="${USER}"
	local GREP_PATTERN=""
	
	# Parse arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
			-p|--partition)
				PARTS="$2"
				shift 2
				;;
			*)
				GREP_PATTERN="$1"
				shift
				;;
		esac
	done
	
	# Default grep pattern if none provided
	GREP_PATTERN="${GREP_PATTERN:-nf-}"
	
	local JIDS
	JIDS=($(squeue -t "$STATE" -u "$USERNAME" -h -o "%.18i %.50j" | awk -v pattern="$GREP_PATTERN" '$2 ~ pattern {print $1}'))
	
	if (( ${#JIDS[@]} == 0 )); then
		echo "No jobs found for user '$USERNAME' in state '$STATE' with '$GREP_PATTERN' in job name."
		return 0
	fi
	
	echo "Reassigning ${#JIDS[@]} job(s) for user '$USERNAME' in state '$STATE' with '$GREP_PATTERN' in name to partitions: $PARTS"
	
	for jid in "${JIDS[@]}"; do
		if (( DRYRUN )); then
			echo "scontrol update JobId=$jid Partition=\"$PARTS\""
			echo "scontrol requeue $jid"
		elif scontrol update JobId="$jid" Partition="$PARTS"; then
			echo "Updated partition for job $jid"
		else
			echo "Failed to update job $jid"
		fi
	done
}

